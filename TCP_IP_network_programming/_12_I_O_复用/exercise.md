## 1. 请解释复用技术的通用含义，并说明何为 IO 复用。

复用技术是指在一个系统中，同一项资源可以被多个用户或多个请求共享使用。在硬件、软件以及网络通讯中，复用技术都有广泛的应用。

在计算机领域，复用通常是指在同一时间周期内，让多个进程或任务共享同一资源（如CPU、内存、硬盘等）从而提高系统资源的使用率和效率。这种方式常见于计算机操作系统中的时间片轮转调度、内存的虚拟管理等。

I/O复用是指让一个进程能同时处理多个I/O请求，或者同时监听多个文件描述符的技术，也叫事件驱动。在Linux系统中，I/O复用的方式主要有select，poll，和epoll。

I/O复用主要解决的是如何处理并发IO，即一个线程如何同时处理多个IO请求的问题。它使得我们可以使用单进程或者少量线程，高效地处理大量IO请求，对于服务器程序来说特别有用。

比如说一个服务器程序，可能同时需要处理数以千计的客户端连接，每个连接可能都会有数据需要读取或者写入。如果采用一个线程处理一个连接的方式，那么线程的数量将非常巨大，带来的上下文切换开销也非常大。通过使用I/O复用，一个线程就可以处理多个连接的IO请求。这样，我们就可以用较少的线程，处理较多的连接，提高服务器程序的性能。

## 2. 多进程并发服务器的缺点有哪些? 如何在 I/O 复用服务器端中弥补?

多进程并发服务器的设计简单，易于理解和实现，但也有一些缺点，包括：

1. 进程的创建和销毁成本相对较高，每个进程都拥有独立的地址空间，操作系统需要为每个进程分配和管理资源，这会产生相当大的开销。 

2. 进程数量太多会造成大量上下文切换，消耗CPU资源。并且，操作系统能够有效管理的进程数量是有限的，过多的进程可能会导致系统性能下降。

3. 进程间的通信复杂，需要通过专门的IPC机制来完成，编程相对困难。

4. 多进程模型对系统资源的需求较高，尤其是内存资源，因为每个进程都需要独立的内存空间和系统资源。

然而，I/O复用技术可以对上述问题进行一定程度的弥补：

1. 通过使用I/O复用，可以让一个进程同时处理多个客户端的连接请求。这样，不需要频繁地创建和销毁进程，节约了系统资源。

2. I/O复用也能减少上下文切换的次数，每个进程能处理的连接数目大大增加，从而减少了进程自身数量，降低了上下文切换带来的开销。

3. 使用I/O复用，所有的客户端连接都是在同一个进程内部进行处理的，所以不存在进程间通信的问题，简化了编程难度。

4. 由于I/O复用减少了进程的数量，因此对系统资源的需求也得到了降低。

所以，I/O复用技术对多进程并发服务器的缺点有很好的弥补作用，能实现更高效、更可靠的并发服务器设计。


## 3. 复用服务器端需要 select 函数。下列关于 select 函数使用方法的描述错误的是?

a. 调用select函数前需要集中I/O监视对象的文件描述符。

b. 若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册。

## 1. 请解释复用技术的通用含义，并说明何为 IO 复用。

复用技术是指在一个系统中，同一项资源可以被多个用户或多个请求共享使用。在硬件、软件以及网络通讯中，复用技术都有广泛的应用。

在计算机领域，复用通常是指在同一时间周期内，让多个进程或任务共享同一资源（如CPU、内存、硬盘等）从而提高系统资源的使用率和效率。这种方式常见于计算机操作系统中的时间片轮转调度、内存的虚拟管理等。

I/O复用是指让一个进程能同时处理多个I/O请求，或者同时监听多个文件描述符的技术，也叫事件驱动。在Linux系统中，I/O复用的方式主要有select，poll，和epoll。

I/O复用主要解决的是如何处理并发IO，即一个线程如何同时处理多个IO请求的问题。它使得我们可以使用单进程或者少量线程，高效地处理大量IO请求，对于服务器程序来说特别有用。

比如说一个服务器程序，可能同时需要处理数以千计的客户端连接，每个连接可能都会有数据需要读取或者写入。如果采用一个线程处理一个连接的方式，那么线程的数量将非常巨大，带来的上下文切换开销也非常大。通过使用I/O复用，一个线程就可以处理多个连接的IO请求。这样，我们就可以用较少的线程，处理较多的连接，提高服务器程序的性能。

## 2. 多进程并发服务器的缺点有哪些? 如何在 I/O 复用服务器端中弥补?

多进程并发服务器的设计简单，易于理解和实现，但也有一些缺点，包括：

1. 进程的创建和销毁成本相对较高，每个进程都拥有独立的地址空间，操作系统需要为每个进程分配和管理资源，这会产生相当大的开销。 

2. 进程数量太多会造成大量上下文切换，消耗CPU资源。并且，操作系统能够有效管理的进程数量是有限的，过多的进程可能会导致系统性能下降。

3. 进程间的通信复杂，需要通过专门的IPC机制来完成，编程相对困难。

4. 多进程模型对系统资源的需求较高，尤其是内存资源，因为每个进程都需要独立的内存空间和系统资源。

然而，I/O复用技术可以对上述问题进行一定程度的弥补：

1. 通过使用I/O复用，可以让一个进程同时处理多个客户端的连接请求。这样，不需要频繁地创建和销毁进程，节约了系统资源。

2. I/O复用也能减少上下文切换的次数，每个进程能处理的连接数目大大增加，从而减少了进程自身数量，降低了上下文切换带来的开销。

3. 使用I/O复用，所有的客户端连接都是在同一个进程内部进行处理的，所以不存在进程间通信的问题，简化了编程难度。

4. 由于I/O复用减少了进程的数量，因此对系统资源的需求也得到了降低。

所以，I/O复用技术对多进程并发服务器的缺点有很好的弥补作用，能实现更高效、更可靠的并发服务器设计。

## 3. 复用服务器端需要 select 函数。下列关于 select 函数使用方法的描述错误的是? 

a. 调用 select 函数前需要集中 I/O 监视对象的文件描述符

b. 若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册

c. 复用服务器端同一时间只能服务于1个客户端，因此，需要服务的客户端接入服务器端后只能等待。

d. 与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此，可以减少因创建进程产生的服务器端的负担。

b、c

a. 调用select函数前需要集中I/O监视对象的文件描述符

是的，这个说法是正确的。

select函数是一种I/O复用技术，它允许程序同时监视多个文件描述符（包括套接字），以检查它们是否已经准备好进行读写操作。调用select函数前，通常需要使用fd_set这样的数据结构集合来保存和管理需要监视的文件描述符。

具体来说，我们可以使用FD_ZERO宏来清空fd_set类型的变量，使用FD_SET宏将文件描述符添加到fd_set中，使用FD_CLR宏从fd_set中删除一个文件描述符，使用FD_ISSET宏检查fd_set中是否包含某个文件描述符。

所以，在调用select函数前，我们需要将所有要监视的文件描述符添加到一个或多个fd_set中，并通过select的参数传递给它，然后由select根据这些文件描述符的I/O状态来进行阻塞或者唤醒程序。

b. 若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册

这个说法其实是不正确的。

实际上，每次调用select函数后，fd_set集合会被修改，只剩下那些满足I/O条件（可以读/写/出错）的文件描述符。也就是说，select会改变你传入的文件描述符集合的内容。因此，如果你想要在下一次循环中再次检查这些文件描述符，你需要在每次调用select函数之前重新设置这个文件描述符集合。

所以，与其说是“重复注册”，不如说是我们需要在每次调用select函数之前，重新设置或更新我们想要监听的文件描述符集合。


c. 复用服务器端同一时间只能服务于1个客户端，因此，需要服务的客户端接入服务器端后只能等待。

这个说法是不正确的。

在I/O复用服务器模型中，同一时间内，服务器可以处理多个客户端的请求。

I/O复用技术，例如select、poll、epoll等，在服务器端可以同时处理多个客户端的连接请求。当任何一个客户端的连接请求准备好（即可以读取或者写入数据）时，服务器就开始处理这个请求。因此，在同一时间，服务器可能在等待多个I/O操作，并在它们准备好时进行处理。

```C
while (true) {
    // 重置fd_set
    FD_ZERO(&readset);
    FD_SET(serv_sock, &readset);
    for (i = 0; i < client_count; i++)
        FD_SET(clnt_socks[i], &readset);

    // 监听socket
    if (select(max_sock+1, &readset, NULL, NULL, NULL) == -1)
        error_handling("select() error");

    ...
}
```

因此，服务器端可以同时处理多个客户端的请求，而不是只能服务于一个客户端，其他客户端必须等待。当然，实际的处理能力取决于服务器的性能和并发设计的效率。

d. 与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此，可以减少因创建进程产生的服务器端的负担。

这个说法是正确的。

基于select的复用服务器模型只需要一个进程，就可以同时处理多个客户端的请求。在每次循环中，它使用select来检查所有的文件描述符，看哪些已经准备好读取或写入。如果有任何一个文件描述符准备好了，它就进行相应的处理。

而多进程或者多线程的服务器模型，对于每一个连接请求，通常会创建一个新的进程或者线程来处理。这种模型的优点是编程模型较为简单明了，但缺点是如果并发连接数较多，会产生大量的进程或者线程，对系统的压力比较大，因此通常需要进程或线程池等技术来进行优化。

因此，基于select的服务器模型，优点是并发处理能力强，资源占用相对较小，尤其在处理大量并发连接，但每个连接上交互数据较少的情况下，比多进程和多线程模型更有优势。


## 4. select 函数的观察对象中应包含服务器端套接字(监听套接字 )，那么应将其包含到哪一类监听对象集合? 请说明原因。

服务器端套接字（监听套接字）应该被包含在读操作的文件描述符集合（例如，在select函数中用于检查可读状态的fd_set类型的集合）中。

原因是：当一个客户端试图连接到服务器时，这被视为对服务器监听套接字的"读操作"。服务器会通过监听套接字接收到一个连接请求，并通过接受这个请求来创建一个新的套接字用于和客户端进行通信。

因此，我们需要将服务器监听套接字放入读操作的文件描述符集合中，以便让select函数能够检测到新的客户端连接请求。当select函数检测到监听套接字可读（即有新的客户端连接请求时），我们就可以调用accept函数来接受这个连接请求。

示例代码如下：

```C
fd_set readfds;
FD_ZERO(&readfds);
FD_SET(server_socket, &readfds);

select(server_socket + 1, &readfds, NULL, NULL, NULL);

if (FD_ISSET(server_socket, &readfds)) {
    int client_socket = accept(server_socket, NULL, NULL);
    // 处理新的客户端连接...
}
```
这段代码创建了一个fd_set类型的读操作文件描述符集合，然后通过FD_SET函数将服务器监听套接字加入集合。之后通过select函数来监听是否有可读操作。当有新的客户端连接请求时，监听套接字变为可读，调用FD_ISSET来确认，然后调用accept接受新的客户端连接。

## 5. select 函数中使用的 `fd_set` 结构体在 Windows 和 Linux 中具有不同声明。请说明区别，同时5解释存在区别的必然性。
d. 与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此，可以减少因创建进程产生的服务器端的负担。

## 4. select 函数的观察对象中应包含服务器端套接字(监听套接字 )，那么应将其包含到哪一类监听对象集合? 请说明原因。


## 5. select 函数中使用的 fd_set 结构体在 Windows 和 Linux 中具有不同声明。请说明区别，同时解释存在区别的必然性。
 
