### 1. 下列关于进程的说法错误的是？

a. 从操作系统的角度，进程是程序运行的单位

b. 进程根据创建的方式建立父子关系

c. 进程可以包含其他进程，即一个进程的内存空间可以包含其他进程

d. 子进程可以创建其他子进程，而创建出来的子进程还可以创建子进程，但是所有这些进程只与一个父进程建立父子关系

c、d

a. 从操作系统的角度，进程是程序运行的单位

对的，这个说法是正确的。从操作系统的角度来看，进程是程序执行的基本单位，是操作系统资源分配和调度的一个独立单位。

一个进程包括一个运行的程序，该程序的当前值（变量、输入和输出的数据），和一个执行状态。每个进程都有自己的独立的内存空间，调度器根据需要可以将进程从磁盘装载到内存，并把它分配到一个或多个处理器上运行。

进程在执行过程中可能会产生子进程，子进程自身也可以产生其他子进程，形成一个进程树。系统为每一个进程分配不同的资源，如CPU时间、内存空间等，而进程则通过系统调用来请求使用这些资源或者进行进程间通讯。

总的来说，进程是操作系统分配资源和调度的基本单位，是程序运行的一个重要环境。

b. 进程可以包含其他进程，即一个进程的内存空间可以包含其他进程

是的，这个说法是正确的。进程在创建新的进程时，创建出来的新进程被称作为子进程，而用来创建新进程的进程则被称为父进程。这样就在两个进程之间建立了父子关系。

这种关系主要是由fork或者clone等系统调用来创建的。这些系统调用会创建一个与原进程（父进程）几乎完全相同的新进程（子进程），它们的代码、数据和状态等几乎都是一样的，但是它们的进程ID是不同的，并且它们的部分资源如文件描述符表、缓冲区等是分开的。

父子进程关系主要体现在进程的管理和资源的继承上，如子进程会继承父进程的环境变量、文件描述符等资源，当子进程结束时，需要父进程进行清理（回收子进程的资源），否则会产生僵尸进程。

因此，进程的父子关系不仅建立在创建的方式上，也体现了操作系统管理进程，以及进程资源的继承和清理等方面。

c. 进程可以包含其他进程，即一个进程的内存空间可以包含其他进程

这个说法并不准确。每个进程都有自己独立的地址空间，一个进程不能访问另外一个进程的内存，除非采取一些特殊的机制（比如通过进程间通信等手段）来进行通信。

操作系统使用一种叫作进程隔离的技术，确保一个进程在地址空间中的数据不被其它进程访问到，一方面可以保护程序的数据安全，另一方面当一个进程发生错误时，不会影响到其他进程。

尽管进程之间不能直接访问对方的内存空间，但是它们可以通过一些方式进行交流，比如通过管道、信号、套接字、共享内存、消息队列等方式进行进程间通信（IPC, Inter-Process Communication）。

所以，一个进程的内存空间不可以包含其他进程，每个进程在操作系统中都是独立存在的，拥有各自的资源及内存空间。

d. 子进程可以创建其他子进程，而创建出来的子进程还可以创建子进程，但是所有这些进程只与一个父进程建立父子关系

这个说法并不准确。在进程的创建上，一般是父进程创建子进程，子进程可以继续创建子进程，但每个子进程的父进程是创建它的那个进程，而不是最初的那个父进程。

例如，如果存在一个进程A，它创建了子进程B，然后B又创建了子进程C。在这个情况下，C的父进程是B，而不是A。每个子进程会逐级地与自己的父进程建立父子关系，而不是只与最初的父进程建立关系。

因此，所有这些进程只与创建它们的那一个父进程建立父子关系，新创建的子进程并不直接与最初的父进程建立父子关系。这种层级的父子关系构成了进程间的树状结构。




### 2. 调用fork函数将创建子进程，下面关于子进程的描述错误的是？

a. 父进程销毁时候也会同时销毁子进程

b. 子进程是复制父进程所有资源创建出来的进程

c. 父子进程共享全局变量

d. 通过fork函数创建的子进程将执行从开始到fork函数调用为止的代码

a、c、d


a. 父进程销毁时候也会同时销毁子进程

这个说法并不完全准确。父进程结束时，子进程不会立即被销毁。实际上，子进程会被操作系统标记为"孤儿进程"，并被init进程（进程号为1的进程）所接手。init进程周期性地进行清理工作，对孤儿进程调用wait()方法来收集其退出状态，从而完成对孤儿进程的清理工作。

然而，如果父进程在销毁前先停止其子进程的执行（例如，通过发送SIGTERM信号），然后再调用wait()来读取子进程的终止状态，那么这样子就可以在父进程销毁时同时销毁子进程。这个过程常常被用来保证父进程在结束运行时，其子进程不会成为孤儿进程，从而保证了系统的整洁。

但是，如果不采取这样的步骤，通常子进程不会因为父进程的销毁而直接销毁。所以，这个说法并不完全准确，是否能同时销毁需要看具体实施的方式。


b. 子进程是复制父进程所有资源创建出来的进程

这个说法基本上是准确的，但需要些许解释。

在UNIX/Linux系统中，子进程是通过fork()系统调用由父进程创建的。在fork()调用过程中，子进程复制了父进程的地址空间，包括代码和数据段，堆和栈等。而复制过程并不是简单的一一复制，而是采用了写时复制（copy-on-write，COW）的技术。在初次复制的时候，复制的是虚拟内存地址的映射关系，而不是整块内存的内容，只有在写操作发生时，才会复制整块内存，这种现象被称为页面错误（page fault）。

所以说，子进程是复制父进程所有资源创建出来的进程，但这种复制更贴切的称呼应该是懒加载（lazy load）。尽管子进程和父进程在fork()执行完返回后都拥有近乎相同的内存布局，但实际上只有当子进程试图修改这些共享页面时，才会发生真正的物理拷贝行为。

而除了内存资源外，子进程还会继承父进程的其他一些属性，比如环境变量、打开的文件描述符等，但也有一些资源是不会被复制的，比如父进程的未决闹钟、信号掩码等。


c. 父子进程共享全局变量

这个说法并不正确。在UNIX/Linux系统中，父进程在创建子进程时，子进程会复制父进程的全部资源，但这个复制过程是一种复制语义，而非共享语义。换句话说，父进程和子进程各自拥有一套完全独立的资源，而非共享资源。

所以全局变量虽然在父进程中被复制到子进程中，但子进程中的全局变量仅仅是父进程全局变量的一份独立副本，它们并不共享。也就是说，父进程对全局变量的修改不会影响到子进程中全局变量的值，同样，子进程对全局变量的修改也不会影响到父进程中全局变量的值。

所以，不能说父子进程共享全局变量。

d. 通过fork函数创建的子进程将执行从开始到fork函数调用为止的代码

这个说法不正确。通过fork函数创建的子进程并不会从程序的开始重新执行，而是从fork声明的地方继续执行。子进程从父进程fork的地方开始运行，并且它将得到父进程在此时的变量状态的副本。

当一个进程执行fork时，操作系统会创建一个新的进程（子进程），这个新进程的状态几乎完全复制了原来的进程（父进程）。然后，这两个进程（父进程和子进程）将继续并行运行，并从fork系统调用返回。这一点可能看起来有些奇怪，但实际上，父进程和子进程只是在fork系统调用后的第一条指令开始并行执行的。所以，子进程并不会执行从开始到fork函数调用之间的代码。


### 3. 创建子进程时候，将复制父进程的所有内容，此时的复制对象也包含套接字文件描述符，编写程序验证复制的文件描述符整数值是否和原始的文件描述符数值相同

### 4. 请说明进程变为僵尸进程的过程以及预防措施

进程变为僵尸进程的过程：

1. 当一个进程结束运行（自然结束或因某种原因被终止），它并没有立即送出。操作系统维护了进程的一些状态信息，这些信息包括这个已经终止的进程的退出状态、进程运行的CPU时间等。这样做是为了让父进程有机会得知子进程的这些状态信息。

2. 如果子进程已经结束，而父进程尚未通过调用wait或waitpid函数来获取子进程的状态信息，那么这个已经结束的子进程便会进入僵尸状态，成为僵尸进程。此时，这个僵尸进程将只保留最小的运行信息——进程ID、退出状态等，以供父进程之后查询。

预防僵尸进程的措施：

1. “善后处理”，把wait或waitpid函数用于父进程，以便fetchAll终止的子进程的状态信息。这将消除所有已经终止，但尚未被父进程wait或waitpid的子进程，也就是所有的僵尸进程。

2. 使用信号处理机制。当子进程结束时，操作系统会向父进程发送SIGCHLD信号。父进程可以编写处理SIGCHLD信号的处理函数，在其中调用wait或waitpid来获取子进程的状态信息。即使是并发大量结束的子进程，也可因此避免产生僵尸进程。

3. 如果父进程不关心子进程的退出状态，子进程也可以在开始时调用setsid()函数使自己成为新的会话组长和进程组长，并与原先的终端断开连接，这样父进程不调用wait/waitpid时，子进程会被init进程接管，子进程结束后，init自动回收，也不会产生僵尸进程。

请注意，长期大量的僵尸进程会消耗系统资源，影响系统的正常运行，应尽力避免。

### 5. 如果在未注册 SIGINT 信号的情况下输入 Ctrl+C， 将由操作系统默认的事件处理器终止程序，但是如果直接注册 Ctrl+C 信号的处理器，则程序不会终止，而是调用程序员指定的事件处理器，编写注册函数的程序，完成下面的功能：

“输入 Ctrl+C 时候，询问是否确定退出程序，输入 Y 则终止程序“

另外，编写程序使其每隔1秒输出简单的字符串，并使用上述事件处理器注册代码

